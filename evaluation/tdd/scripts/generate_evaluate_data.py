import sys
import os
import json
# import subprocess

max_string_length = 12000

def create_tdd2_prompt(language,prompt,callCode_test):
    callCode_tests_string = f"```{language}\n"+callCode_test+"\n```\n"
    
    instruction_text = f"""You are a professional {language} software engineer proficient in utilizing the Test-Driven Development (TDD) methodology. Your development process consists of two steps: first, generating test cases based on natural language requirements, and second, creating functional code that ensures passing those test cases.
Currently, you're embarking on the Second step, which involves generating functional code that ensures passing of all tests and can be directly executed.
You'll be provided with the following information:
1. A development requirement described in natural language.
2. Test cases generated by you in the first step of TDD development based on the aforementioned requirement.
You will ONLY return functional code including necessary imports and dependencies, make sure it compile without errors, use reflection to invoke private methods. 
Note that no additional explanations required.

Here are the information:
1. A development requirement described in natural language.
{prompt}

2. Test cases generated by you in the first step of TDD development based on the aforementioned requirement.
{callCode_tests_string}
"""
    return instruction_text


def create_tdd1_prompt(language,prompt):

    instruction_text = f"""You are a professional {language} software engineer proficient in utilizing the Test-Driven Development (TDD) methodology. Your development process consists of two steps: first, generating test cases based on natural language requirements, and second, creating functional code.
Currently, you're embarking on the first step, where you'll derive a complete test class for a focal method from a development requirement described in natural language.
You will ONLY return unit test code including necessary imports and dependencies, make sure it compile without errors, use reflection to invoke private methods, and won't test scenarios beyond the stated development requirement. 
Note that no additional explanations required.

Here are the development requirement described in natural language:
{prompt}

Please note that the test class you return should include multiple test cases covering different functionalities. There is no upper limit on the number of test cases, but you need to ensure that the test cases provide high test coverage and test extreme and special cases of the code as much as possible.
"""

    return instruction_text

def create_tdd1_prompt_one_shot(language,prompt,callCode_test):
    callCode_tests_string = f"```{language}\n"+callCode_test+"\n```\n"
    
    instruction_text = f"""You are a professional {language} software engineer proficient in utilizing the Test-Driven Development (TDD) methodology. Your development process consists of two steps: first, generating test cases based on natural language requirements, and second, creating functional code.
Currently, you're embarking on the first step and a unit test class for a requirement is under development, your task is to generate a new test method for this test class to test new aspects that have not been covered before.
You'll be provided with the following information:
1. A development requirement described in natural language.
2. Source code of unit test method that is already developed(With imports and dependencies).
You will ONLY return unit test code including necessary imports and dependencies, make sure it compile without errors, use reflection to invoke private methods, and won't test scenarios beyond the stated development requirement. 
Note that no additional explanations required.

Here are the information:
1. A development requirement described in natural language.
{prompt}

2. Source code of unit test method that is already developed(With imports and dependencies).
{callCode_tests_string}

Please note that the test class you return should include multiple test cases covering different functionalities. There is no upper limit on the number of test cases, but you need to ensure that the test cases provide high test coverage and test extreme and special cases of the code as much as possible.
"""
    
    return instruction_text

def tdd_seperate(language,input_path):
    output_dict = {}

    with open(input_path, "r") as f:
        #读取jsonl文件
        lines = f.readlines()
        for line in lines:
            line = line.strip()
            if len(line) == 0:
                continue
            #将json字符串转换为字典
            json_dict = eval(line)
            task_id = json_dict["task_id"]
            print(task_id)
            prompt = json_dict["prompt"]
            example_test = json_dict["example_test"]
            test = json_dict["test"]
            code = json_dict["declaration"]+"\n"+json_dict["canonical_solution"]

            tdd1_prompt = create_tdd1_prompt(language,prompt)
            tdd1_prompt_one_shot = create_tdd1_prompt_one_shot(language,prompt,example_test)
            tdd2_prompt = create_tdd2_prompt(language,prompt,example_test)

            output_dict[task_id] = {
                "task_id": task_id,
                "prompt": prompt,
                "test": test,
                "code": code,
                "prompts":{
                    "prompt_tdd1": tdd1_prompt,
                    "prompt_tdd1_one_shot": tdd1_prompt_one_shot,
                    "prompt_tdd2": tdd2_prompt
                },
                "HumanEval-X": json_dict
            }
                
    return output_dict


if __name__ == "__main__":
    language = "java" if len(sys.argv) < 2 else sys.argv[1] 
    input_path = "/cpfs/29a75185021b187f/aigccode/user/cuizhe/UT-LM/evaluation/tdd/RawData/java/data_java_data_humaneval.jsonl" if len(sys.argv) < 3 else sys.argv[2]
    output_path = "/cpfs/29a75185021b187f/aigccode/user/cuizhe/UT-LM/evaluation/tdd/prompts/java" if len(sys.argv) < 4 else sys.argv[3]
    
    tdd_results = tdd_seperate(language,input_path)

    print("Writing to file...")
    with open(os.path.join(output_path,"tdd.json"), "w") as f:
        json.dump(tdd_results,f,indent=4,ensure_ascii=False)
